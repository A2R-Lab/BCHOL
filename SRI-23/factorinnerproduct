//fact_state: Factorization of Q\A
//fact_input: Factorization of R\B
//fact_lambda: -A

template <typename T>
__device__
void FactorInnerProduct(T* A_B, T* fact_state, T* fact_input, T* fact_lambda, int index, int data_level, int fact_level, int nstates, int ninput, int nhorizon) {
    
    double* C1_state;
    double* C1_input;

    double* F1_state;
    double* F1_input;
    double* F1_lambda;

    double* C2_state; 
    double* C2_input;

    double* F2_state;
    double* F2_input;
    double* F2_lambda;

    //Retrieve single NdFactor out of data
    int linear_index = index + nhorizon * data_level;
    C1_state = A_B + (linear_index * dyn_step);
    C1_input = A_B + (linear_index * dyn_step + nstates * nstates);

    linear_index = index + nhorizon * fact_level;
    F1_state = fact_state + linear_index;
    F1_input = fact_input + linear_index;
    F2_lambda = fact_lambda + linear_index;

    linear_index = (index + 1) + nhorizon * data_level;
    C2_state = A_B + (linear_index * dyn_step);
    C2_input = A_B + (linear_index * dyn_step + nstates * nstates);

    linear_index = (index + 1) + nhorizon * fact_level;
    F2_state = fact_state+linear_index;
    F2_input = fact_input+linear_index;
    F2_lambda = fact_lambda+linear_index;

    //Use the precomputed Cholesky factorization to solve for y at each parent level 
    double *S = F2_lambda; //Initialized to a zero matrix

    //S = C1x * F1x
    glass::gemm(nstates, nstates, ninput, 1.0, C1_state, F1_state, -1.0, S);

    //S = C1u * F1u + S
    glass::gemm(nstates, ninput, nstates, 1.0, C1_input, F1_input, 1.0, S);

    //S = C2x * F2x + S
    glass::gemm(nstates, nstates, nstates, 1.0, C2_state, F2_state, 1.0, S);

    //S = C2u * F2u + S
    glass::gemm(nstates, ninput, nstates, C2_input, F2_input, 1.0, S);

    return;
}
